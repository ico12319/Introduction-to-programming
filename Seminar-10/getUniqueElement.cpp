#include <iostream>

// Какви биха били различните идеи за решение?
// 1. Започваме да броим по колко пъти се среща всеки елемент - този който се среща веднъж бива върнат. 
// 2. Сортираме масива и намираме елемента, който си няма другарче.

// Може би най - елегантния начин това да бъде решено е следния
int getUniqueElement(const int arr[], unsigned size)
{
    int buff = 0;
    for (size_t i = 0; i < size; i++)
    {
        buff = buff ^ arr[i];
    }
    return buff;
}
// Защо това работи?
// 1. a ^ a = 0                                 винаги имайки XOR на два еднакви бита той дава 0.
// 2. a ^ b = b ^ a                             това следва гледайки таблицата на XOR.
// 3. a ^ b ^ a = a ^ a ^ b = 0 ^ b = b         Първото равенство го получихме използвайки 2. Второто използвайки 1.
// Използвайки тази интуиция еднаквите числа ще се развият до нули и ще остане само това което няма другарче.

int main()
{
    constexpr unsigned EXAMPLE_SIZE = 9;
    int example[EXAMPLE_SIZE] = {1, 10, -3, 1, 4, 145, -3, 10, 4};
    std::cout << getUniqueElement(example, EXAMPLE_SIZE);
}