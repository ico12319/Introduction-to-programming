# Четиринадесети семинар по увод в програмирането - 11.01.2024

## Рекурсия
До момента, решавайки задачи, използвахме главно цикли. Разбира се, разделяхме кода на по-малки логически части, с помощта на функции.
Задачите решавахме с една или повече итерации върху някаква променлива - точно заради това наричаме този подход `итеративен`.

Всъщност има и други методи чрез които подхождаме към проблемите. Но защо са ни други подходи? Този не работи ли добре?

Практически погледнато подходът на решение на една задача се избира спрямо задачата. Знаейки повече подходи и стратегии за решаване на една задача можем да подходим правилно в повече случаи.

Задачите, които могат да се решат с рекурсия, могат да се решат и с итерация. Понякога обаче информацията се описва по-добре рекурсивно (чрез декомпозиция).

Та какво е рекурсия? Рекурсивна функция наричаме функция, която извиква себе си.

```cpp
int main()
{
    main();
}
```

Това очевидно е отвратителен пример. Програмата ще завърши с грешка.
Ако една функция извиква себе си няма ли да зациклим до безкрайност? Ако сме невнимателни ще зациклим, да (не до безкрайност а докато ни свърши стека).

За да може да са ефективни рекурсивните алгоритми имат и **дъно**. Достигайки дъното не извикваме отново функцията а връщаме някакъв отговор, който често е лесен да се пресметне.

(За момента) можем да разглеждаме рекурсивните функции като функции, съставени от две части:
1. Дъно (или базов случай): Изчисляваме резултата на база на информацията която имаме. Това изчисление обикновено се случва бързо - в дъното резултата често е очевиден.
2. Рекурсивна стъпка: Изчисляваме резултата с помощта на едно или повече **рекурсивни извиквания**.

Нека разгледаме пример. Как бихме реализирали задачата за намиране на сума на масив итеративно:
```cpp
int sum(const int* arr, unsigned size)
{
    int toReturn = 0;
    for(size_t i = 0; i < size; i++)
    {
        toReturn += arr[i];
    }
    return toReturn;
}
```
Как бихме решили задачата рекурсивно?
```cpp
int sumRec(const int* arr, unsigned size)
{
    if(size == 0)
    {
        // Базов случай. На празен масив сумата е 0.
        return 0;
    }

    // В противен случай вземи сумата на първия елемент и я събери
    // със сумата на arr[1...n].
    return arr[0] + sumRec(arr + 1, size - 1);
}
```

(не особено забавен, но подобен) пример би бил следния:
Колко завивания са нужни да завиеш крушка
* Ако е завита - нула.
* Ако не е завита завърти веднъж, задай ми същия въпрос и добави единица към отговора.

Какви са предимствата на рекурсията? 
* По-кратък и ясен код. 
* Част от проблемите биха се решили доста по-сложно използвайки итерация. Причината е, рекурсивния характер на информацията с която работят.

Недостатъци:
* Често (но не винаги) са по-бавни от итерацията.
* Заемат повече памет заради рекурсивни извиквания.

## Примери
### Как ще напишем факториел
Първия начин, който ще разгледаме е подобен на примера със сумата.

```cpp
unsigned factorial(unsigned n)
{
    if(n == 0)
    {
        // Дъно: 0! = 1 по дефиниция.
        return 1;
    }

    // Рекурсивна стъпка n! = n * (n-1)!
    return n * factorial(n - 1);
}
```

За пълнота нека разгледаме още една версия
```cpp
unsigned factorialAccumulate(unsigned n, unsigned accumulate)
{
    if(n == 0)
    {
        return accumulate;
    }

    return factorialAccumulate(n - 1, accumulate * n);
}

unsigned factorial(unsigned n)
{
    return factorialAccumulate(n, 1);
}
```
Двете функции са еквивалентни. Просто едната не изчаква да се стигне до дъното за да започне да умножава.

### Как ще напишем Фибоначи
Нека сега разгледаме пример как да напишем функция, която намира n-тото число на Фибоначи.

```cpp
unsigned fibb(unsigned n)
{
    if(n == 0 || n == 1)
    {
        return 1;
    }

    return fibb(n - 1) + fibb(n - 2);
}
```
Това е един от най-стандартните примери за рекурсия. Примерът директно прилага дефиницията на числата на Фибоначи.
Какво може да се обърка?

Функцията прави твърде много изчисления. Нека разгледаме какво ще се случи ако я извикаме.

fibb(44) = fibb(43) + fibb(42) = fibb(42) + fibb(41) + fibb(41) + fibb(40) = ...

Забелязваме, че функцията прави твърде много преизчисления на една и съща стойност. Примерно fibb(5) ще се извика много повече от 1 път.

### Как да напишем power и fast power.
### Как да напишем binary search.
### Как да напишем проверка дали низ е палиндром.
### Търсене на пътища в лабиринти.

Лабиринт дефинираме като двумерна матрица съдържаща числата 0, 1 и 2. Представяме си, че сме човече, което се разхожда из тази матрица.
Целта ни е да достигнем до 2. Тръгваме от някоя клетка, която е 0 и можем да преминаваме само през нули. Можем да се движим нагоре, надолу, наляво и надясно.

Напишете функция ```cpp bool hasPath(int** board, unsigned x, unsigned y);``` която връща дали е възможно да стигнем от координати ```(x, y)``` до някоя двойка.