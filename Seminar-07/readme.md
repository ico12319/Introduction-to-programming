# Седми семинар по увод в програмирането - 12.11.2023

## Ключовата дума const
Нека разгледаме функцията `printArray`:

```cpp
#include <iostream>

using namespace std;

void printArray(const int[] arr, unsigned length)
{
    for(unsigned i = 0; i < length; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```
В случая единственото нещо което превим е да четем от масива (той никъде не се променя). Удобно е една част от променливите ни да бъдат константи (от тях единствено се чете и те не се променят). Ключовака дума `const` прави точно това - казва, че една променлива няма да бъде променена.

В случая, подавайки arr като `const int[]` компилаторът би дал съобщение за грешка ако се опитаме да променим `arr`.
Всяка променлива може да е константа.

```cpp
const double PI = 3.141592; // PI никога не се променя
```

Можем да използваме `const` за да определяме големината на масиви. 
```cpp
const int MAX_SIZE = 100;

int main()
{
    int arr[MAX_SIZE]; // това е ок
}
```
Каква е разликата между `const` и `constexpr` обаче? В горния пример константата може да се разгледа като `constexpt`. Не всеки `const` служи като големина на масив. `const` казва, че стойността на променлива няма да се промени. Тази стойност може да е станала ясна и в runtime, но тя няма да се промени. `constexpr` казва, че стойността е ясна (може да де изчисли) още по време на компилация. 

```cpp
#include <iostream>

using namespace std;

const int get()
{
	int x = 0;
	cin >> x;

	return x;
}

int main()
{
	const int size = get(); // size е const.
	size++; // грешка
	int arr[size]; // Грешка
}
```

Въпреки, че size е `const` няма как да го използваме за размер, понеже стойността не е ясна по време на компилация. 

## Обръщане на масив
Да се напише функция ```cpp void reverse(int arr[], unsigned size)```, която обръща масив.

Пример:

Вход: [1, 4, 3, 5, 2]
Изход: [2, 5, 3, 4, 1]

## Решето на Ератостен
Искаме да създадем проста система, която получава от стандартния вход числа и ни казва дали са прости или не.

Пример:
> 1
> Not prime
> 2
> Prime
> 1024
> Not prime
> 145
> Not prime

Системата работи с числа от 1 до 1024.

## Двоично търсене
Да се напише функция ```cpp int binarySearch(const int arr[], unsigned length, int elem)```. `arr` e сортиран масив, `length` e дължината му а elem е число което може да е в масива, но може и да не е. Очаква се да върнем индекса на числото в масива ако се среща и -1 ако не се.

## Позиционни бройни системи
Бройните системи са метод за представяне на числа чрез краен брой символи наречени **цифри**. Познаваме десетичната бройна система. Защо се нарича десенична?

$2345 = 2 * 10^3 + 3 * 10^2 + 4 * 10^1 + 5 * 10^0$
Ако си представим числото като наредена последователност от цифри $a = a_{n-1}, a_{n-2}, \dots, a_0$ то стойността му е $\sum_{i = 0}^{n-1} 10^i*a_{i}$. В случая позицията на цифрата играе роля, от там идва и името **позиционна**. За представяне на числата се използват 10 символа - от там десетична.

По същия начин можем да дефинираме и двоична бройна система. Отново имаме $a = a_{n-1}, a_{n-2}, \dots, a_0$ само, че този път $a_i \in \{0, 1\}$ (т.е. използваме два символа).

Намирането на стойността на числото се извършва по същия начин. Примерно $1101 = 1 * 2^3 + 1 * 2^2 + 0 * 2 + 1 * 2^0 = 13$.

Предимството на двоичната бройна система е, че използва само два символа, което я прави по - лесна за обработка от машина.

Осмичната бройна система, както и шестнаддесетичната също се използват на някои места.

В шестнаддесетичната бройна система цифрите са от 0 до 9 както и символите от `a` до `f`.
В езика С++:
```cpp
#include <iostream>
using namespace std;

int main()
{
    int octal = 01230; // Когато има 0 пред числото то е записано в осмична бройна система
    cout << octal << endl;

    int hexadecimal = 0xC0FFEE; // Когато пред числото има 0x то е разглеждано като число в шестнаддесетична бройна система
    cout << hexadecimal << endl;
}
```

Обобщавайки тази идея можем да имаме произволни к-ични позиционни бройни системи.

## 1s and 2s complement. Представяне на числа в паметта. signed/unsigned стойности.